"""
The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
"""


from math import sqrt


def compute_triangle_number(n):
    """
    Sum of natural numbers from 1 to n. Python range is right-exclusive, so add 1 for inclusivity
    :param n: current evaluation number
    :return: sum of the first n natural numbers
    """
    return sum(list(range(1, n + 1)))


def get_factors(n):
    """
    Get all factors for n. Checking primality only requires going up to the floor of the sqrt(n) + 1, and since all
    numbers can be represented as prime factors, we only need to go up to the prime limit and get the inverse factors
    through division
    :param n: Number for which to find factors
    :return: return the factors for the number, sorted
    """

    # Store the factors as a set to prevent duplication
    factors = set()

    # Factors are prime and start at 1. Only need to go up to floor(sqrt(n)) + 1 due to primes. Explained above
    for i in range(1, int(sqrt(n)) + 1):
        # Check to see if the number can be strictly divided by i
        if n % i == 0:
            # If i is a divisor, add it to the set
            factors.add(i)
            # Since i is a divisor, there has to exist an alternate divisor (I think there's a theorem for this)
            # Divide n by i and add to the set of factors as well
            factors.add(n / i)

    # Convert the set to a list and sort - not needed but helps with readability
    factors = sorted([int(i) for i in factors])
    return factors


if __name__ == "__main__":
    max_factors = 0
    current_triangle_number = 1
    index = 1

    while max_factors < 500:
        current_triangle_number = compute_triangle_number(index)
        max_factors = len(get_factors(current_triangle_number))
        index += 1

    print(current_triangle_number, max_factors)
